"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("@jest/globals");
var __1 = require("../..");
var apiTestHelpers_1 = require("../apiTestHelpers");
var ItemBuffer_1 = require("../ItemBuffer");
var types_1 = require("./types");
var userAction_1 = __importDefault(require("./userAction"));
globals_1.jest.useFakeTimers();
globals_1.jest.mock('../../sdk/registerFaro', function () { return ({
    faro: {
        api: {
            pushEvent: globals_1.jest.fn(),
        },
    },
}); });
describe('UserAction', function () {
    var transports;
    beforeEach(function () {
        transports = apiTestHelpers_1.mockTransports;
        globals_1.jest.spyOn(ItemBuffer_1.ItemBuffer.prototype, 'flushBuffer').mockImplementation(function (cb) {
            if (cb) {
                var dummyItem = { type: __1.TransportItemType.EVENT, payload: {}, meta: {} };
                cb(dummyItem);
            }
        });
    });
    afterEach(function () {
        globals_1.jest.clearAllMocks();
        globals_1.jest.clearAllTimers();
    });
    it('initializes in Started state and sets startTime', function () {
        var ua = new userAction_1.default({ name: 'foo', transports: transports, trigger: 'foo' });
        expect(ua.getState()).toBe(types_1.UserActionState.Started);
        expect(typeof ua.startTime).toBe('number');
        expect(ua.startTime > 0).toBe(true);
    });
    it('cancel() flushes the buffer and goes to Cancelled', function () {
        var ua = new userAction_1.default({ name: 'foo', transports: transports, trigger: 'foo' });
        ua.cancel();
        expect(ua.getState()).toBe(types_1.UserActionState.Cancelled);
        expect(ItemBuffer_1.ItemBuffer.prototype.flushBuffer).toHaveBeenCalled();
        expect(transports.execute).not.toHaveBeenCalled();
    });
    it('end() will not fire if action is cancelled', function () {
        var ua = new userAction_1.default({ name: 'foo', transports: transports, trigger: 'foo' });
        ua.cancel();
        ua.end();
        expect(ua.getState()).toBe(types_1.UserActionState.Cancelled);
    });
    it('end() will send items with action payload', function () {
        var ua = new userAction_1.default({ name: 'foo', transports: transports, trigger: 'foo' });
        ua.end();
        expect(ua.getState()).toBe(types_1.UserActionState.Ended);
        expect(transports.execute).not.toHaveBeenCalledWith('koko');
    });
    it('addItem returns true and buffers when state is Started', function () {
        var userAction = new userAction_1.default({ name: 'foo', transports: transports, trigger: 'foo' });
        var item = { type: __1.TransportItemType.EVENT, payload: {}, meta: {} };
        var result = userAction.addItem(item);
        expect(result).toBe(true);
    });
    it('addItem returns false when state is Halted', function () {
        var userAction = new userAction_1.default({ name: 'foo', transports: transports, trigger: 'foo' });
        userAction.halt();
        var item = { type: __1.TransportItemType.EVENT, payload: {}, meta: {} };
        var result = userAction.addItem(item);
        expect(result).toBe(false);
    });
    it('addItem returns false when state is Cancelled', function () {
        var userAction = new userAction_1.default({ name: 'foo', transports: transports, trigger: 'foo' });
        userAction.cancel();
        var item = { type: __1.TransportItemType.EVENT, payload: {}, meta: {} };
        var result = userAction.addItem(item);
        expect(result).toBe(false);
    });
    it('addItem returns false when state is Ended', function () {
        var userAction = new userAction_1.default({ name: 'foo', transports: transports, trigger: 'foo' });
        userAction.end();
        var item = { type: __1.TransportItemType.EVENT, payload: {}, meta: {} };
        var result = userAction.addItem(item);
        expect(result).toBe(false);
    });
});
//# sourceMappingURL=userAction.test.js.map