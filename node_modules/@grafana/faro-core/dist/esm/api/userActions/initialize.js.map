{"version":3,"file":"initialize.js","sourceRoot":"","sources":["../../../../src/api/userActions/initialize.ts"],"names":[],"mappings":"AAAA,OAAO,EAA4D,MAAM,OAAO,CAAC;AAEjF,OAAO,EAAE,UAAU,EAAE,MAAM,sBAAsB,CAAC;AAElD,OAAO,EAAE,oBAAoB,EAAE,eAAe,EAAE,iCAAiC,EAAE,MAAM,SAAS,CAAC;AACnG,OAAO,EAML,eAAe,GAEhB,MAAM,SAAS,CAAC;AACjB,OAAO,UAAU,MAAM,cAAc,CAAC;AAEtC,MAAM,CAAC,MAAM,qBAAqB,GAAG,IAAI,UAAU,EAAqB,CAAC;AAEzE,MAAM,UAAU,wBAAwB,CAAC,EACvC,UAAU,EACV,cAAc,EACd,MAAM,GAKP;;IACC,MAAM,2BAA2B,GAAG,MAAA,MAAM,CAAC,0BAA0B,0CAAE,WAAW,CAAC;IAEnF,uEAAuE;IACvE,QAAQ;IACR,IAAI,gBAAwC,CAAC;IAE7C,wEAAwE;IACxE,kCAAkC;IAClC,MAAM,eAAe,GAAsC,CACzD,IAAY,EACZ,UAAmC,EACnC,OAAgC,EACC,EAAE;QACnC,MAAM,wBAAwB,GAAG,mBAAmB,EAAE,CAAC;QAEvD,IAAI,wBAAwB,KAAK,SAAS,EAAE,CAAC;YAC3C,MAAM,UAAU,GAAG,IAAI,UAAU,CAAC;gBAChC,IAAI;gBACJ,UAAU;gBACV,UAAU;gBACV,OAAO,EAAE,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW,KAAI,iCAAiC;gBAClE,UAAU,EAAE,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,UAAU,KAAI,oBAAoB,CAAC,MAAM;gBAC9D,2BAA2B;aAC5B,CAAC,CAAC;YACH,UAAU;iBACP,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,eAAe,CAAC,KAAK,EAAE,eAAe,CAAC,SAAS,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;iBAC7E,KAAK,EAAE;iBACP,SAAS,CAAC,GAAG,EAAE;gBACd,gBAAgB,GAAG,SAAS,CAAC;YAC/B,CAAC,CAAC,CAAC;YAEL,qBAAqB,CAAC,MAAM,CAAC;gBAC3B,IAAI,EAAE,eAAe;gBACrB,UAAU,EAAE,UAAU;aACvB,CAAC,CAAC;YACH,gBAAgB,GAAG,UAAU,CAAC;YAE9B,OAAO,gBAAgB,CAAC;QAC1B,CAAC;aAAM,CAAC;YACN,cAAc,CAAC,KAAK,CAAC,2FAA2F,CAAC,CAAC;YAClH,OAAO,SAAS,CAAC;QACnB,CAAC;IACH,CAAC,CAAC;IAEF,MAAM,mBAAmB,GAA0C,GAAoC,EAAE;QACvG,OAAO,gBAAgB,CAAC;IAC1B,CAAC,CAAC;IAEF,MAAM,GAAG,GAAmB;QAC1B,eAAe;QACf,mBAAmB;KACpB,CAAC;IAEF,OAAO,GAAG,CAAC;AACb,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,yBAAyB,CAAC,UAA2C,EAAE,IAAmB;IACxG,IAAI,CAAC,UAAU,EAAE,CAAC;QAChB,OAAO,KAAK,CAAC;IACf,CAAC;IACD,MAAM,KAAK,GAAI,UAAqD,aAArD,UAAU,uBAAV,UAAU,CAA6C,QAAQ,EAAE,CAAC;IACjF,IAAI,KAAK,KAAK,eAAe,CAAC,OAAO,EAAE,CAAC;QACtC,OAAO,KAAK,CAAC;IACf,CAAC;IACA,UAAuD,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;IACvE,OAAO,IAAI,CAAC;AACd,CAAC","sourcesContent":["import { type InternalLogger, type TransportItem, type Transports } from '../..';\nimport type { Config } from '../../config';\nimport { Observable } from '../../utils/reactive';\n\nimport { UserActionImportance, userActionStart, userActionStartByApiCallEventName } from './const';\nimport {\n  type StartUserActionOptions,\n  type UserActionInterface,\n  type UserActionInternalInterface,\n  type UserActionMessage,\n  type UserActionsAPI,\n  UserActionState,\n  type UserActionTransportItemBuffer,\n} from './types';\nimport UserAction from './userAction';\n\nexport const userActionsMessageBus = new Observable<UserActionMessage>();\n\nexport function initializeUserActionsAPI({\n  transports,\n  internalLogger,\n  config,\n}: {\n  transports: Transports;\n  config: Config;\n  internalLogger: InternalLogger;\n}): UserActionsAPI {\n  const trackUserActionsExcludeItem = config.userActionsInstrumentation?.excludeItem;\n\n  // Currently running user action. It can be in either started or halted\n  // state\n  let activeUserAction: UserAction | undefined;\n\n  // If there is a an action already running, return undefined to indicate\n  // we were not able to create one.\n  const startUserAction: UserActionsAPI['startUserAction'] = (\n    name: string,\n    attributes?: Record<string, string>,\n    options?: StartUserActionOptions\n  ): UserActionInterface | undefined => {\n    const currentRunningUserAction = getActiveUserAction();\n\n    if (currentRunningUserAction === undefined) {\n      const userAction = new UserAction({\n        name,\n        transports,\n        attributes,\n        trigger: options?.triggerName || userActionStartByApiCallEventName,\n        importance: options?.importance || UserActionImportance.Normal,\n        trackUserActionsExcludeItem,\n      });\n      userAction\n        .filter((v) => [UserActionState.Ended, UserActionState.Cancelled].includes(v))\n        .first()\n        .subscribe(() => {\n          activeUserAction = undefined;\n        });\n\n      userActionsMessageBus.notify({\n        type: userActionStart,\n        userAction: userAction,\n      });\n      activeUserAction = userAction;\n\n      return activeUserAction;\n    } else {\n      internalLogger.error('Attempted to create a new user action while one is already running. This is not possible.');\n      return undefined;\n    }\n  };\n\n  const getActiveUserAction: UserActionsAPI['getActiveUserAction'] = (): UserActionInterface | undefined => {\n    return activeUserAction;\n  };\n\n  const api: UserActionsAPI = {\n    startUserAction,\n    getActiveUserAction,\n  };\n\n  return api;\n}\n\n/**\n * Adds an item to the buffer associated with the given UserAction.\n * The item will only be added if the UserAction is in the Started state.\n * @param userAction The UserAction instance\n * @param item The item to add to the buffer\n * @returns {boolean} True if the item was added, false otherwise\n */\nexport function addItemToUserActionBuffer(userAction: UserActionInterface | undefined, item: TransportItem): boolean {\n  if (!userAction) {\n    return false;\n  }\n  const state = (userAction as unknown as UserActionInternalInterface)?.getState();\n  if (state !== UserActionState.Started) {\n    return false;\n  }\n  (userAction as unknown as UserActionTransportItemBuffer).addItem(item);\n  return true;\n}\n"]}