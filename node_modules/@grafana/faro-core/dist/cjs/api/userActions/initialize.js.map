{"version":3,"file":"initialize.js","sourceRoot":"","sources":["../../../../src/api/userActions/initialize.ts"],"names":[],"mappings":";;;;;;AAkBA,4DA+DC;AASD,8DAUC;AAlGD,iDAAkD;AAElD,iCAAmG;AACnG,iCAQiB;AACjB,4DAAsC;AAEzB,QAAA,qBAAqB,GAAG,IAAI,qBAAU,EAAqB,CAAC;AAEzE,SAAgB,wBAAwB,CAAC,EAQxC;;QAPC,UAAU,gBAAA,EACV,cAAc,oBAAA,EACd,MAAM,YAAA;IAMN,IAAM,2BAA2B,GAAG,MAAA,MAAM,CAAC,0BAA0B,0CAAE,WAAW,CAAC;IAEnF,uEAAuE;IACvE,QAAQ;IACR,IAAI,gBAAwC,CAAC;IAE7C,wEAAwE;IACxE,kCAAkC;IAClC,IAAM,eAAe,GAAsC,UACzD,IAAY,EACZ,UAAmC,EACnC,OAAgC;QAEhC,IAAM,wBAAwB,GAAG,mBAAmB,EAAE,CAAC;QAEvD,IAAI,wBAAwB,KAAK,SAAS,EAAE,CAAC;YAC3C,IAAM,UAAU,GAAG,IAAI,oBAAU,CAAC;gBAChC,IAAI,MAAA;gBACJ,UAAU,YAAA;gBACV,UAAU,YAAA;gBACV,OAAO,EAAE,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW,KAAI,yCAAiC;gBAClE,UAAU,EAAE,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,UAAU,KAAI,4BAAoB,CAAC,MAAM;gBAC9D,2BAA2B,6BAAA;aAC5B,CAAC,CAAC;YACH,UAAU;iBACP,MAAM,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,uBAAe,CAAC,KAAK,EAAE,uBAAe,CAAC,SAAS,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,EAA9D,CAA8D,CAAC;iBAC7E,KAAK,EAAE;iBACP,SAAS,CAAC;gBACT,gBAAgB,GAAG,SAAS,CAAC;YAC/B,CAAC,CAAC,CAAC;YAEL,6BAAqB,CAAC,MAAM,CAAC;gBAC3B,IAAI,EAAE,uBAAe;gBACrB,UAAU,EAAE,UAAU;aACvB,CAAC,CAAC;YACH,gBAAgB,GAAG,UAAU,CAAC;YAE9B,OAAO,gBAAgB,CAAC;QAC1B,CAAC;aAAM,CAAC;YACN,cAAc,CAAC,KAAK,CAAC,2FAA2F,CAAC,CAAC;YAClH,OAAO,SAAS,CAAC;QACnB,CAAC;IACH,CAAC,CAAC;IAEF,IAAM,mBAAmB,GAA0C;QACjE,OAAO,gBAAgB,CAAC;IAC1B,CAAC,CAAC;IAEF,IAAM,GAAG,GAAmB;QAC1B,eAAe,iBAAA;QACf,mBAAmB,qBAAA;KACpB,CAAC;IAEF,OAAO,GAAG,CAAC;AACb,CAAC;AAED;;;;;;GAMG;AACH,SAAgB,yBAAyB,CAAC,UAA2C,EAAE,IAAmB;IACxG,IAAI,CAAC,UAAU,EAAE,CAAC;QAChB,OAAO,KAAK,CAAC;IACf,CAAC;IACD,IAAM,KAAK,GAAI,UAAqD,aAArD,UAAU,uBAAV,UAAU,CAA6C,QAAQ,EAAE,CAAC;IACjF,IAAI,KAAK,KAAK,uBAAe,CAAC,OAAO,EAAE,CAAC;QACtC,OAAO,KAAK,CAAC;IACf,CAAC;IACA,UAAuD,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;IACvE,OAAO,IAAI,CAAC;AACd,CAAC","sourcesContent":["import { type InternalLogger, type TransportItem, type Transports } from '../..';\nimport type { Config } from '../../config';\nimport { Observable } from '../../utils/reactive';\n\nimport { UserActionImportance, userActionStart, userActionStartByApiCallEventName } from './const';\nimport {\n  type StartUserActionOptions,\n  type UserActionInterface,\n  type UserActionInternalInterface,\n  type UserActionMessage,\n  type UserActionsAPI,\n  UserActionState,\n  type UserActionTransportItemBuffer,\n} from './types';\nimport UserAction from './userAction';\n\nexport const userActionsMessageBus = new Observable<UserActionMessage>();\n\nexport function initializeUserActionsAPI({\n  transports,\n  internalLogger,\n  config,\n}: {\n  transports: Transports;\n  config: Config;\n  internalLogger: InternalLogger;\n}): UserActionsAPI {\n  const trackUserActionsExcludeItem = config.userActionsInstrumentation?.excludeItem;\n\n  // Currently running user action. It can be in either started or halted\n  // state\n  let activeUserAction: UserAction | undefined;\n\n  // If there is a an action already running, return undefined to indicate\n  // we were not able to create one.\n  const startUserAction: UserActionsAPI['startUserAction'] = (\n    name: string,\n    attributes?: Record<string, string>,\n    options?: StartUserActionOptions\n  ): UserActionInterface | undefined => {\n    const currentRunningUserAction = getActiveUserAction();\n\n    if (currentRunningUserAction === undefined) {\n      const userAction = new UserAction({\n        name,\n        transports,\n        attributes,\n        trigger: options?.triggerName || userActionStartByApiCallEventName,\n        importance: options?.importance || UserActionImportance.Normal,\n        trackUserActionsExcludeItem,\n      });\n      userAction\n        .filter((v) => [UserActionState.Ended, UserActionState.Cancelled].includes(v))\n        .first()\n        .subscribe(() => {\n          activeUserAction = undefined;\n        });\n\n      userActionsMessageBus.notify({\n        type: userActionStart,\n        userAction: userAction,\n      });\n      activeUserAction = userAction;\n\n      return activeUserAction;\n    } else {\n      internalLogger.error('Attempted to create a new user action while one is already running. This is not possible.');\n      return undefined;\n    }\n  };\n\n  const getActiveUserAction: UserActionsAPI['getActiveUserAction'] = (): UserActionInterface | undefined => {\n    return activeUserAction;\n  };\n\n  const api: UserActionsAPI = {\n    startUserAction,\n    getActiveUserAction,\n  };\n\n  return api;\n}\n\n/**\n * Adds an item to the buffer associated with the given UserAction.\n * The item will only be added if the UserAction is in the Started state.\n * @param userAction The UserAction instance\n * @param item The item to add to the buffer\n * @returns {boolean} True if the item was added, false otherwise\n */\nexport function addItemToUserActionBuffer(userAction: UserActionInterface | undefined, item: TransportItem): boolean {\n  if (!userAction) {\n    return false;\n  }\n  const state = (userAction as unknown as UserActionInternalInterface)?.getState();\n  if (state !== UserActionState.Started) {\n    return false;\n  }\n  (userAction as unknown as UserActionTransportItemBuffer).addItem(item);\n  return true;\n}\n"]}