{"version":3,"file":"faroUserActionSpanProcessor.js","sourceRoot":"","sources":["../../src/faroUserActionSpanProcessor.ts"],"names":[],"mappings":";;;AAAA,0CAA4D;AAG5D,sDAAgG;AAEhG,sIAAsI;AACtI,gCAAgC;AAChC,EAAE;AACF,iCAAiC;AACjC,8CAA8C;AAC9C,sBAAsB;AACtB,2BAA2B;AAC3B,uCAAuC;AACvC,qIAAqI;AACrI,EAAE;AACF,yHAAyH;AACzH;IACE,qCAAoB,SAAwB;QAAxB,cAAS,GAAT,SAAS,CAAe;IAAG,CAAC;IAEhD,gDAAU,GAAV;QACE,OAAO,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,CAAC;IACrC,CAAC;IAED,6CAAO,GAAP,UAAQ,IAAU,EAAE,aAAsB;QACxC,IAAM,UAAU,GAAG,mBAAI,CAAC,GAAG,CAAC,mBAAmB,EAAE,CAAC;QAClD,IACE,UAAU;YACV,CAAC,UAAqD,aAArD,UAAU,uBAAV,UAAU,CAA6C,QAAQ,EAAE,MAAK,8BAAe,CAAC,OAAO;YAC9F,IAAI,CAAC,IAAI,KAAK,cAAQ,CAAC,MAAM,EAC7B,CAAC;YACD,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,uBAAuB,CAAC,EAAE,CAAC;gBAC9C,IAAI,CAAC,UAAU,CAAC,uBAAuB,CAAC,GAAG,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAE,IAAI,CAAC;YAC9D,CAAC;YACD,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,2BAA2B,CAAC,EAAE,CAAC;gBAClD,IAAI,CAAC,UAAU,CAAC,2BAA2B,CAAC,GAAG,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAE,QAAQ,CAAC;YACtE,CAAC;QACH,CAAC;QAED,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,EAAE,aAAa,CAAC,CAAC;IAC9C,CAAC;IAED,2CAAK,GAAL,UAAM,IAAkB;QACtB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IAC7B,CAAC;IAED,8CAAQ,GAAR;QACE,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,CAAC;IACnC,CAAC;IACH,kCAAC;AAAD,CAAC,AAhCD,IAgCC;AAhCY,kEAA2B","sourcesContent":["import { type Context, SpanKind } from '@opentelemetry/api';\nimport type { ReadableSpan, Span, SpanProcessor } from '@opentelemetry/sdk-trace-web';\n\nimport { faro, type UserActionInternalInterface, UserActionState } from '@grafana/faro-web-sdk';\n\n// There is very rare race condition that would result in span being attached to different user action. As shown in the diagram below.\n// The scenario is the following\n//\n// 1. User action (id = 1) starts\n// 2. Things happen for a given amount of time\n// 3. User action ends\n// 4. Span processor starts\n// 5. A new user action (id = 2) starts\n// 6. Span processor tries to attach the `faro.user.action` attributes based on the state of the current user action which is id = 2.\n//\n// This ultimately depends on the processing delay of the span processor which deems this race condition highly unlikely.\nexport class FaroUserActionSpanProcessor implements SpanProcessor {\n  constructor(private processor: SpanProcessor) {}\n\n  forceFlush(): Promise<void> {\n    return this.processor.forceFlush();\n  }\n\n  onStart(span: Span, parentContext: Context): void {\n    const userAction = faro.api.getActiveUserAction();\n    if (\n      userAction &&\n      (userAction as unknown as UserActionInternalInterface)?.getState() === UserActionState.Started &&\n      span.kind === SpanKind.CLIENT\n    ) {\n      if (!span.attributes['faro.action.user.name']) {\n        span.attributes['faro.action.user.name'] = userAction?.name;\n      }\n      if (!span.attributes['faro.action.user.parentId']) {\n        span.attributes['faro.action.user.parentId'] = userAction?.parentId;\n      }\n    }\n\n    this.processor.onStart(span, parentContext);\n  }\n\n  onEnd(span: ReadableSpan): void {\n    this.processor.onEnd(span);\n  }\n\n  shutdown(): Promise<void> {\n    return this.processor.shutdown();\n  }\n}\n"]}