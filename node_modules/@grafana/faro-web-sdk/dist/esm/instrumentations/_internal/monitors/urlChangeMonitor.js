import { Observable } from '@grafana/faro-core';
export const MESSAGE_TYPE_URL_CHANGE = 'url-change';
let urlChangeObservable;
let isInstrumented = false;
let lastHref;
let originalPushState;
let originalReplaceState;
let onPopStateHandler;
let onHashChangeHandler;
let onNavigateHandler;
let originalNavigateEventIntercept;
export function monitorUrlChanges() {
    if (!urlChangeObservable) {
        urlChangeObservable = new Observable();
        lastHref = location.href;
    }
    function emit(trigger, toOverride) {
        const next = toOverride !== null && toOverride !== void 0 ? toOverride : location.href;
        if (next !== lastHref) {
            urlChangeObservable.notify({ type: MESSAGE_TYPE_URL_CHANGE, from: lastHref, to: next, trigger });
            lastHref = next;
        }
    }
    if (!isInstrumented) {
        const hasNavigation = 'navigation' in window && 'NavigateEvent' in window;
        if (hasNavigation) {
            // Prefer Navigation API when supported: do not patch history or add popstate/hashchange listeners
            onNavigateHandler = (e) => {
                try {
                    const destination = e === null || e === void 0 ? void 0 : e.destination;
                    if ((destination === null || destination === void 0 ? void 0 : destination.sameDocument) && typeof destination.url === 'string') {
                        emit('navigate', destination.url);
                    }
                }
                catch (_err) {
                    // Swallow to avoid impacting host app
                }
            };
            window.navigation.addEventListener('navigate', onNavigateHandler);
            const NavigateEventConstructor = window.NavigateEvent;
            if (NavigateEventConstructor &&
                NavigateEventConstructor.prototype &&
                typeof NavigateEventConstructor.prototype.intercept === 'function') {
                if (!originalNavigateEventIntercept) {
                    originalNavigateEventIntercept = NavigateEventConstructor.prototype.intercept;
                }
                // Wrap intercept to detect soft navigations (cross-document turned same-document)
                NavigateEventConstructor.prototype.intercept = function (options) {
                    try {
                        const canIntercept = !!(this === null || this === void 0 ? void 0 : this.canIntercept);
                        const destination = this === null || this === void 0 ? void 0 : this.destination;
                        if (canIntercept &&
                            destination &&
                            destination.sameDocument === false &&
                            typeof destination.url === 'string') {
                            emit('navigate-intercept', destination.url);
                        }
                    }
                    catch (_err) {
                        // ignore
                    }
                    return originalNavigateEventIntercept.call(this, options);
                };
            }
            isInstrumented = true;
        }
        else {
            // Fallback: history API patching + popstate/hashchange
            if (!originalPushState) {
                originalPushState = window.history.pushState;
            }
            window.history.pushState = function (...args) {
                const result = originalPushState.apply(window.history, args);
                emit('pushState');
                return result;
            };
            if (!originalReplaceState) {
                originalReplaceState = window.history.replaceState;
            }
            window.history.replaceState = function (...args) {
                const result = originalReplaceState.apply(window.history, args);
                emit('replaceState');
                return result;
            };
            onPopStateHandler = () => emit('popstate');
            onHashChangeHandler = () => emit('hashchange');
            window.addEventListener('popstate', onPopStateHandler);
            window.addEventListener('hashchange', onHashChangeHandler);
            isInstrumented = true;
        }
    }
    return urlChangeObservable;
}
// Test-only utility to reset state between tests
export function __resetUrlChangeMonitorForTests() {
    var _a, _b;
    if (onPopStateHandler) {
        window.removeEventListener('popstate', onPopStateHandler);
    }
    if (onHashChangeHandler) {
        window.removeEventListener('hashchange', onHashChangeHandler);
    }
    if (onNavigateHandler && ((_a = window.navigation) === null || _a === void 0 ? void 0 : _a.removeEventListener)) {
        window.navigation.removeEventListener('navigate', onNavigateHandler);
    }
    if (originalPushState) {
        window.history.pushState = originalPushState;
    }
    if (originalReplaceState) {
        window.history.replaceState = originalReplaceState;
    }
    if (originalNavigateEventIntercept && ((_b = window.NavigateEvent) === null || _b === void 0 ? void 0 : _b.prototype)) {
        window.NavigateEvent.prototype.intercept = originalNavigateEventIntercept;
    }
    urlChangeObservable = undefined;
    isInstrumented = false;
    lastHref = undefined;
    onPopStateHandler = undefined;
    onHashChangeHandler = undefined;
    onNavigateHandler = undefined;
    originalPushState = undefined;
    originalReplaceState = undefined;
    originalNavigateEventIntercept = undefined;
}
//# sourceMappingURL=urlChangeMonitor.js.map